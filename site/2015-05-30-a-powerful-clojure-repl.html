<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <title>A powerful Clojure REPL with Vinyasa</title>
  <style type="text/css">code{white-space: pre;}</style>
  <style type="text/css">
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; }
code > span.dt { color: #902000; }
code > span.dv { color: #40a070; }
code > span.bn { color: #40a070; }
code > span.fl { color: #40a070; }
code > span.ch { color: #4070a0; }
code > span.st { color: #4070a0; }
code > span.co { color: #60a0b0; font-style: italic; }
code > span.ot { color: #007020; }
code > span.al { color: #ff0000; font-weight: bold; }
code > span.fu { color: #06287e; }
code > span.er { color: #ff0000; font-weight: bold; }
  </style>
  <link rel="stylesheet" href="style.css" type="text/css" />
</head>
<body>
<div class="site">
<h1 class="blog-title">presumably for side effects</h1>
<hr class="blog-title-rule">
<div class="post">
<div id="header">
<h1 class="title">A powerful Clojure REPL with Vinyasa</h1>
</div>
<p>As a good member of the Lisp family, Clojure's pride is its REPL. This may seem unusual if you're coming from another language. But the workflow popular with many Clojure developers requires a powerful REPL as its foundation.</p>
<p>In essence, a REPL -- or read-eval-print loop -- is a prompt that allows you to enter instructions to modify the state of the program, printing the results to the terminal. On the surface, Clojure's REPL is similar to tools provided by other dynamic languages: Python's <code>ipython</code>, Ruby's <code>irb</code>, PHP's <code>boris</code>. However, the flexible nature of Lisp makes this simple tool more powerful. In Clojure, you can re-evaluate functions or entire namespaces while keeping the state of the running programming. This enables the programmer to try out a function, make changes to different parts of the system and add code interactively, without ever restarting the REPL.</p>
<p>This feature allows for a different way of working with code, and for many it's hard to go back to a language without a powerful REPL after trying it. There's another -- decidedly more prosaic -- reason why Clojure developers work from inside a REPL: Clojure start-up is painfully slow. A project with a dozen of dependencies may take 10 seconds to start, even on a fast machine. If you're looking for quick feedback loops, as you should, your only possibility is to keep a REPL running and to re-evaluate code on the fly, as you're working on it. The upside is that, once you're connected to the REPL, re-evaluating is almost instant -- and you get all the other benefits of the REPL as a bonus.</p>
<p>As a result of these <em>push</em> and <em>pull</em> factors, Clojure's default workflow involves starting a REPL only once (or at least rarely) and keeping it running for the whole development session. You start <code>lein repl</code> in your project directory, connect using a REPL-aware editor (like CIDER or LightTable), and work dynamically.</p>
<p>This works great for exploring and tinkering with your code. There is, however, one catch: due to limitations of the JVM, <code>leiningen</code> keep your <code>CLASSPATH</code> static throughout the session. Consequently, <code>leiningen</code>'s default configuration requires you to restart the REPL to add Clojure (or Java) dependencies.</p>
<p>Fortunately, <code>leiningen</code> is extensible enough that this feature can be added by using a wonderful library called <code>vinyasa</code>, which allows you to pull dependencies and modify the <code>CLASSPATH</code> after the fact. To do so is surprisingly simple: simply add a configuration file as <code>leiningen</code>'s default user profile. As a first approximation, you can try the <a href="https://gist.github.com/pesterhazy/0d37bfffc9d7264c3b35">profiles.clj</a> that I use:</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">mkdir</span> -p ~/.lein
$ <span class="kw">wget</span> -O ~/.lein/profiles.clj https://gist.githubusercontent.com/pesterhazy/0d37bfffc9d7264c3b35/raw/f754399b79ae39380a0015b6cba85b8ef76d3c72/profiles.clj</code></pre></div>
<p>With this <code>profiles.clj</code> in place, every <code>lein repl</code> you start will have a number of additional tools available in the special <code>./</code> namespace. In particular, you can now pull an additional dependency from <em>clojars</em> in one line of code by typing:</p>
<pre><code>(./pull &#39;org.clojure/data.xml &quot;0.0.8&quot;)
;; =&gt; {[org.clojure/clojure &quot;1.4.0&quot;] nil, [org.clojure/data.xml &quot;0.0.8&quot;] #{[org.clojure/clojure &quot;1.4.0&quot;]}}</code></pre>
<p>after which you can use the library, which now magically appears in the <code>CLASSPATH</code>:</p>
<pre><code>user=&gt; (require &#39;[clojure.data.xml :as xml])
nil
user=&gt; (xml/indent-str (xml/sexp-as-element [:hello &quot;world&quot;]))
&quot;&lt;?xml version=\&quot;1.0\&quot; encoding=\&quot;UTF-8\&quot;?&gt;&lt;hello&gt;world&lt;/hello&gt;\n&quot;</code></pre>
<p>You can even omit the version number, in which case <code>vinyasa</code> will pull in the latest version of the library (and helpfully tell which version it retrieved).</p>
<h2 id="further-reading">Further reading</h2>
<ul>
<li><a href="http://dev.solita.fi/2014/03/18/pimp-my-repl.html">This article</a> explains Vinyasa and many other useful things you can do in a Clojure REPL.</li>
</ul>
</div>
</div>
</body>
</html>
